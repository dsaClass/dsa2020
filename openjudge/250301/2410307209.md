# 状态:[Accepted](http://xzmdsa.openjudge.cn/2025hw3/solution/48617147/)

```
基本信息
#:48617147
题目:250301
提交人:2410307209 朱子轩
内存:5988kB
时间:39ms
语言:Python3
提交时间:2025-03-18 16:52:48
```

## 分析问题&&解决思路：
本题最关键的是动归算法。假设分法为f(n)，我们可以从中拆出一个加数j作为一个最大的拆分数，由于后面还有n-j需要拆分，我们可以用f(n-j)表示，但需注意的是：f(n-j)中不能有超过j的拆分，否则会造成重复。因此，我们可以加上一个“还没有加入超过j拆分的f(n-j)”。例如：f(4)=f(3)[最大拆分为1]+f(2)[最大拆分为2]+f(1)[最大拆分为3]+f(0)[最大拆分为4]。
可以用一个双层循环实现它：
for i in range(1, n + 1):
        for j in range(i, n + 1):
            dp[j] += dp[j - i]
此时每次加入的dp[j-i]都是最大加数不超过i的情况。

## 解题感想：
这题的动归算法还是挺有意思的，也可以用传统的分苹果算法来做。